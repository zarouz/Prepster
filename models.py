# models.py
"""
Defines the SQLAlchemy database models for the application.
Includes User (with authentication fields), Report, and PasswordReset models.
"""

from flask_sqlalchemy import SQLAlchemy
from flask_login import UserMixin
from flask_bcrypt import Bcrypt
from sqlalchemy.sql import func # For database-level default timestamps
import datetime # For calculating token expiry

# Initialize extensions - These will be configured in app.py with the Flask app context
db = SQLAlchemy()
bcrypt = Bcrypt()

class User(db.Model, UserMixin):
    """
    Represents a user in the application.
    Includes fields for authentication, profile information, and relationships.
    Inherits from UserMixin for Flask-Login integration.
    """
    __tablename__ = 'users'

    # Columns based on your `\d users` output and auth requirements
    id = db.Column(db.Integer, primary_key=True) # Auto-increment handled by SQLAlchemy/Postgres sequence
    username = db.Column(db.String(100), unique=True, nullable=False)
    email = db.Column(db.String(100), unique=True, nullable=False, index=True) # Added index for faster lookups
    password_hash = db.Column(db.Text, nullable=False)
    failed_attempts = db.Column(db.Integer, default=0, nullable=False)
    is_locked = db.Column(db.Boolean, default=False, nullable=False)
    is_confirmed = db.Column(db.Boolean, default=False, nullable=False) # For email confirmation status
    confirmation_sent_at = db.Column(db.TIMESTAMP(timezone=True), nullable=True) # Tracks when the last confirmation email was sent
    # confirmed_on = db.Column(db.TIMESTAMP, nullable=True) # Optional: Track when confirmed
    created_at = db.Column(db.TIMESTAMP, server_default=func.now(), nullable=False)
    updated_at = db.Column(db.TIMESTAMP, server_default=func.now(), onupdate=func.now(), nullable=False)

    # Relationships
    # Reports generated by this user. If the user is deleted, their reports are also deleted.
    reports = db.relationship('Report', backref='author', lazy=True, cascade="all, delete-orphan")
    # Password reset tokens associated with this user. If the user is deleted, tokens are deleted.
    # Only one active reset request per user is enforced by logic in auth.py
    password_resets = db.relationship('PasswordReset', backref='user', lazy=True, cascade="all, delete-orphan")

    def __init__(self, username, email, password, is_confirmed=False):
        """
        Initializes a new User instance.
        Hashes the provided password using bcrypt.
        """
        self.username = username.strip()
        self.email = email.lower().strip()
        # Hash the password immediately upon creation
        self.password_hash = bcrypt.generate_password_hash(password).decode('utf-8')
        self.is_confirmed = is_confirmed
        self.is_locked = False
        self.failed_attempts = 0

    def set_password(self, password):
        """Sets a new password, hashing it."""
        self.password_hash = bcrypt.generate_password_hash(password).decode('utf-8')

    def check_password(self, password):
        """
        Checks if the provided password matches the stored hash.
        Returns True if match, False otherwise.
        """
        return bcrypt.check_password_hash(self.password_hash, password)

    def __repr__(self):
        """String representation for User objects (useful for debugging)."""
        return f"<User id={self.id} username='{self.username}' email='{self.email}' confirmed={self.is_confirmed}>"


class Report(db.Model):
    """
    Represents an interview report generated for a user.
    """
    __tablename__ = 'reports'

    # Columns based on your `\d reports` output
    id = db.Column(db.Integer, primary_key=True)
    # ForeignKey links to the 'users' table's 'id' column.
    # 'ondelete=CASCADE' mirrors the DB constraint: if a user is deleted, their reports are deleted.
    user_id = db.Column(db.Integer, db.ForeignKey('users.id', ondelete='CASCADE'), nullable=False, index=True)
    title = db.Column(db.String(255), nullable=True) # Allows NULL title as per schema
    file_path = db.Column(db.Text, nullable=False)
    created_at = db.Column(db.TIMESTAMP, server_default=func.now(), nullable=False)

    def __repr__(self):
        """String representation for Report objects."""
        # The 'author' backref from User model allows accessing the user object directly
        return f"<Report id={self.id} title='{self.title}' user_id={self.user_id}>"


class PasswordReset(db.Model):
    """
    Stores a hash of the password reset token to ensure single-use.
    The token itself is generated by itsdangerous and sent via email.
    """
    __tablename__ = 'password_reset'

    # Columns based on your `\d password_reset` output and the decision to store a hash
    id = db.Column(db.Integer, primary_key=True)
    # Link to the user requesting the reset. Cascade delete ensures tokens are removed if user is deleted.
    user_id = db.Column(db.Integer, db.ForeignKey('users.id', ondelete='CASCADE'), nullable=False, index=True)
    # Store a hash of the itsdangerous token
    token_hash = db.Column(db.String(128), nullable=False, unique=True) # Store hash, ensure it's unique
    created_at = db.Column(db.TIMESTAMP, server_default=func.now(), nullable=False)
    # Expiry is mainly handled by itsdangerous max_age, but can be stored for cleanup tasks
    expires_at = db.Column(db.TIMESTAMP, nullable=False)

    def __init__(self, user_id, token, expires_at):
        """
        Initializes a PasswordReset record.
        Stores the user_id and hashes the provided token.
        """
        self.user_id = user_id
        # Hash the token before storing
        self.token_hash = bcrypt.generate_password_hash(token).decode('utf-8')
        self.expires_at = expires_at

    def check_token(self, token):
        """Checks if the provided raw token matches the stored hash."""
        return bcrypt.check_password_hash(self.token_hash, token)

    def is_expired(self):
        """Checks if the reset request has expired based on stored expiry time."""
        # Compare aware datetime (UTC) with stored aware datetime
        return datetime.datetime.now(datetime.timezone.utc) > self.expires_at.replace(tzinfo=datetime.timezone.utc)

    def __repr__(self):
        """String representation for PasswordReset objects."""
        return f"<PasswordReset id={self.id} user_id={self.user_id} expires_at='{self.expires_at}'>"
